import java.util.*;

/**
 * @author Matt Rueben
 * ^ But initial code was generated by Google Gemini.
 */
public class GroupingBrowser {

    public final int NUM_PEOPLE;
    public final int GROUP_SIZE;       // The required group size

    private long numGroupingsFound = 0;
    public long numCallsToPartnerFinder = 0;

    // This changes a lot during recursion.
    private final List<List<Integer>> currentGrouping = new ArrayList<>();

    // Decides whether to backtrack early.
    private GroupingSearch director = null;


    public GroupingBrowser(int numPeople, int groupSize)
    {
        this.NUM_PEOPLE = numPeople;
        this.GROUP_SIZE = groupSize;
    }


    public void setSearchDirector(GroupingSearch director)
    {
        this.director = director;
    }


    public long getNumGroupingsFound() { return this.numGroupingsFound; }
    public long getNumCallsToPartnerFinder() { return this.numCallsToPartnerFinder; }

    // First of two recursive methods.
    public void formRemainingGroups(List<Integer> ungrouped) {

        // 1. Base Case: If there are no more ungrouped, we found a valid grouping.
        if (ungrouped.isEmpty()) {
            if (this.director != null)
            {
                this.director.submitValidGrouping(currentGrouping);
            }
            numGroupingsFound++;
            // Uncomment the line below if you want to print all groupings (only for very small N)
            //System.out.println("Grouping #" + numGroupingsFound + ": " + currentGrouping);
            return; // Backtrack.
        }

        // When forming a new group,
        // always start with the lowest-indexed remaining student.
        // This yields a canonical order for the groups themselves.
        int firstInGroup = ungrouped.getFirst();
        List<Integer> remaining = ungrouped.subList(1, ungrouped.size());

        // 3. Find K-1 partners for the first student from the remaining list.
        int numPartnersNeeded = GROUP_SIZE - 1;
        int[] partnerIndices = new int[numPartnersNeeded];
        chooseRemainingPartnersForGroup(remaining, numPartnersNeeded, 0, 0, partnerIndices, firstInGroup);
    }

    // Second of two recursive methods.
    private void chooseRemainingPartnersForGroup(List<Integer> possiblePartners, int numPartnersNeeded, int startIdx, int numPartnersFound,
                                                 int[] partnerIndices, int firstInGroup) {

        this.numCallsToPartnerFinder++;
//        try {
//            Thread.sleep(10); // Pauses the thread for 10 milliseconds
//        } catch (InterruptedException e) {
//            // Handle the case where the thread is interrupted while sleeping
//            Thread.currentThread().interrupt(); // Re-interrupt the thread
//            System.err.println("Thread was interrupted during sleep.");
//        }

        // Check if we should backtrack early.
        if (this.director != null && this.director.backtrackingIsOn() && numPartnersFound > 0)
        {
            List<Integer> groupSoFar = new ArrayList<>();

            groupSoFar.add(firstInGroup);

            int[] partnerIndicesSoFar = Arrays.copyOfRange(partnerIndices, 0, numPartnersFound);

            for (int index : partnerIndicesSoFar) {
                int partner = possiblePartners.get(index);
                groupSoFar.add(partner);
            }

            //System.out.println(currentGrouping + " _ " + groupSoFar);

            Collections.sort(groupSoFar); // Important for retrieving saved scores from hash map.

            if (this.director.shouldBacktrack(groupSoFar))
            {
                return; // Backtrack.
            }
        }


        // Base Case for Combinations: We have selected K-1 partners
        if (numPartnersFound == numPartnersNeeded) {
            // A full group has been formed!

            // 1. Create the new group list
            List<Integer> newGroup = new ArrayList<>();
            newGroup.add(firstInGroup);

            // 2. Build the group and the list of students possiblePartners for the next recursion
            Set<Integer> currentGroupStudents = new HashSet<>();
            currentGroupStudents.add(firstInGroup);

            for (int index : partnerIndices) {
                int partner = possiblePartners.get(index);
                newGroup.add(partner);
                currentGroupStudents.add(partner);
            }

            // 3. Sort the group internally. This is for a clear, canonical *output*
            // but the combination logic already guarantees no duplicates are *generated*.
            Collections.sort(newGroup);

            // 4. Update the current grouping and the list of possible partners
            currentGrouping.add(newGroup);

            List<Integer> nextStudents = new ArrayList<>();
            for (int student : possiblePartners) {
                if (!currentGroupStudents.contains(student)) {
                    nextStudents.add(student);
                }
            }

            // 5. Recursive call to find the remaining groups
            formRemainingGroups(nextStudents);

            // 6. Backtrack: Remove the group for the next iteration
            currentGrouping.removeLast();
            return;
        }

        // Recursive step: Iterate over the possiblePartners students to find the next partner.
        // The use of 'i + 1' in the recursive call ensures that students are only
        // selected in increasing order of index, eliminating permutations (order within group).
        for (int i = startIdx; i < possiblePartners.size(); i++) {
            partnerIndices[numPartnersFound] = i;
            // Recursively find the next partner from index i + 1
            chooseRemainingPartnersForGroup(possiblePartners, numPartnersNeeded, i + 1, numPartnersFound + 1, partnerIndices, firstInGroup);
        }
        return;
    }

}
