package search;

import java.util.*;

/**
 * @author Matt Rueben
 * ^ But initial code was generated by Google Gemini.
 */
public class ScheduleSurfer {

    public final int numDays;
    public final int numTimes;
    public final int windowDuration;
    public final int numWindowsToSchedule;

    private long numSchedulesFound = 0;
    //public long numCallsToPartnerFinder = 0;

    // The contents of a lot during recursion.
    private final List<Window> currentSchedule;

    // Decides whether to backtrack early.
    private ScheduleSearch director = null;


    public ScheduleSurfer(int numDays, int numTimes, int windowDuration, int numWindowsToSchedule)
    {
        this.numDays = numDays;
        this.numTimes = numTimes;
        this.windowDuration = windowDuration;
        this.numWindowsToSchedule = numWindowsToSchedule;
        currentSchedule = new ArrayList<>(numWindowsToSchedule);
    }


    public void setSearchManager(ScheduleSearch director)
    {
        this.director = director;
    }


    public void findAllSchedules()
    {
        System.out.println("Trying to find " + this.numWindowsToSchedule + " windows of " + this.windowDuration + " slots each ...");
        long startTime = System.currentTimeMillis();
        this.findAllScheduleCompletions();
        long endTime = System.currentTimeMillis();
        System.out.println("Full groupings explored: " + this.numSchedulesFound);
        System.out.printf("Time taken for generation: %.2f seconds%n", (endTime - startTime) / 1000.0);
    }

    private void findAllScheduleCompletions() {

//        try {
//            Thread.sleep(10); // Pauses the thread for 10 milliseconds
//        } catch (InterruptedException e) {
//            // Handle the case where the thread is interrupted while sleeping
//            Thread.currentThread().interrupt(); // Re-interrupt the thread
//            System.err.println("Thread was interrupted during sleep.");
//        }

        // Base Case: we have defined a complete schedule.
        if (this.currentSchedule.size() == this.numWindowsToSchedule) {

            // Save it.
            if (this.director != null)
            {
                List<Window> copyOfCurrentSchedule = new ArrayList<>(currentSchedule);
                this.director.submitValidSchedule(copyOfCurrentSchedule);
            }
            this.numSchedulesFound++;
            // Uncomment the line below if you want to print all groupings (only for very small N).
//            System.out.println("Grouping #" + this.numSchedulesFound + ": " + this.currentSchedule);

            // Backtrack.
            return;
        }

        // Check if we should backtrack early.
        if (!this.currentSchedule.isEmpty() && this.director != null && this.director.backtrackingIsOn())
        {
            if (this.director.shouldBacktrack(this.currentSchedule))
            {
                return; // Backtrack.
            }
        }

        // Recursion case for each possible next window ...
        // ... starting just after the last one to avoid identical schedules.
        List<Window> nextWindowList;
        if (this.currentSchedule.isEmpty())
        {
            nextWindowList = findAllValidFutureWindows(0,0);
        }
        else
        {
            Window currentLastWindow = this.currentSchedule.getLast();
            nextWindowList = findAllValidFutureWindows(currentLastWindow);
        }

        for (Window nextWindow : nextWindowList)
        {
            this.currentSchedule.add(nextWindow);
            findAllScheduleCompletions();
            this.currentSchedule.removeLast();
        }
        return; // Backtrack.
    }


    private List<Window> findAllValidFutureWindows(int firstDayToTry, int firstStartTimeToTry)
    {
        List<Window> validFutureWindows = new ArrayList<>();

        for (int day = firstDayToTry; day < this.numDays; day++)
        {
            int finalValidStartTime = this.numTimes - this.windowDuration;

            int startTime;
            if (day == firstDayToTry)
            {
                startTime = firstStartTimeToTry;
            }
            else
            {
                startTime = 0;
            }

            for ( ; startTime <= finalValidStartTime; startTime++)
            {
                validFutureWindows.add(new Window(day, startTime, this.windowDuration));
            }
        }
        return validFutureWindows;
    }

    private List<Window> findAllValidFutureWindows(Window lastWindow)
    {
        int firstDayToTry = lastWindow.day;

        int lastWindowEndTime = lastWindow.startTime + lastWindow.duration - 1;
        int firstStartTimeToTry = lastWindowEndTime + 1;

        return findAllValidFutureWindows(firstDayToTry, firstStartTimeToTry);
    }

}
