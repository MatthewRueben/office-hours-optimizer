package search;

import java.util.*;

/**
 * @author Matt Rueben
 * ^ But initial code was generated by Google Gemini.
 */
public class ScheduleSurfer {

    public final int NUM_DAYS;
    public final int NUM_TIMES;
    public final int WINDOW_DURATION;
    public final int NUM_WINDOWS_IN_SCHEDULE;

    private long numSchedulesFound = 0;
    //public long numCallsToPartnerFinder = 0;

    // The contents of a lot during recursion.
    private final List<Window> currentSchedule;

    // Decides whether to backtrack early.
    private ScheduleSearch director = null;


    public ScheduleSurfer(int numDays, int numTimes, int windowDuration, int numWindowsInSchedule)
    {
        this.NUM_DAYS = numDays;
        this.NUM_TIMES = numTimes;
        this.WINDOW_DURATION = windowDuration;
        this.NUM_WINDOWS_IN_SCHEDULE = numWindowsInSchedule;
        currentSchedule = new ArrayList<>(numWindowsInSchedule);
    }


    public void setSearchDirector(ScheduleSearch director)
    {
        this.director = director;
    }


    public long getNumSchedulesFound() { return this.numSchedulesFound; }
    //public long getNumCallsToPartnerFinder() { return this.numCallsToPartnerFinder; }


    public void findAllScheduleCompletions() {

        //this.numCallsToPartnerFinder++;
//        try {
//            Thread.sleep(10); // Pauses the thread for 10 milliseconds
//        } catch (InterruptedException e) {
//            // Handle the case where the thread is interrupted while sleeping
//            Thread.currentThread().interrupt(); // Re-interrupt the thread
//            System.err.println("Thread was interrupted during sleep.");
//        }

        // Base Case: we have defined a complete schedule.
        if (this.currentSchedule.size() == this.NUM_WINDOWS_IN_SCHEDULE) {

            // Save it.
            if (this.director != null)
            {
                this.director.submitValidSchedule(currentSchedule);
            }
            this.numSchedulesFound++;
            // Uncomment the line below if you want to print all groupings (only for very small N)
            System.out.println("Grouping #" + this.numSchedulesFound + ": " + this.currentSchedule);

            // Backtrack.
            return;
        }

        // Check if we should backtrack early.
        if (!this.currentSchedule.isEmpty() && this.director != null && this.director.backtrackingIsOn())
        {
            if (this.director.shouldBacktrack(this.currentSchedule))
            {
                return; // Backtrack.
            }
        }

        // Recursion case for each possible next window ...
        // ... starting just after the last one to avoid identical schedules.
        List<Window> nextWindowList;
        if (this.currentSchedule.isEmpty())
        {
            nextWindowList = findAllValidFutureWindows(0,0);
        }
        else
        {
            Window currentLastWindow = this.currentSchedule.getLast();
            nextWindowList = findAllValidFutureWindows(currentLastWindow);
        }

        for (Window nextWindow : nextWindowList)
        {
            this.currentSchedule.add(nextWindow);
            findAllScheduleCompletions();
            this.currentSchedule.removeLast();
        }
        return; // Backtrack.
    }

    private List<Window> findAllValidFutureWindows(int firstDayToTry, int firstStartTimeToTry)
    {
        List<Window> validFutureWindows = new ArrayList<>();

        for (int day = firstDayToTry; day < this.NUM_DAYS; day++)
        {
            int finalValidStartTime = this.NUM_TIMES - this.WINDOW_DURATION;

            int startTime;
            if (day == firstDayToTry)
            {
                startTime = firstStartTimeToTry;
            }
            else
            {
                startTime = 0;
            }

            for ( ; startTime <= finalValidStartTime; startTime++)
            {
                validFutureWindows.add(new Window(day, startTime, this.WINDOW_DURATION));
            }
        }
        return validFutureWindows;
    }

    private List<Window> findAllValidFutureWindows(Window lastWindow)
    {
        int firstDayToTry = lastWindow.day;

        int lastWindowEndTime = lastWindow.startTime + lastWindow.duration - 1;
        int firstStartTimeToTry = lastWindowEndTime + 1;

        return findAllValidFutureWindows(firstDayToTry, firstStartTimeToTry);
    }

}
